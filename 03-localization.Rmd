# Localization Methods  

## Primitive: Weighted Average  
**Description**  
This is simply a weighted average based on number of beeps on a node and max. RSSI values.  

**Usage**  
```{r eval=FALSE}
weighted_average(freq, beeps, node, node_health=NULL, MAX_NODES=0, tag_id=NULL, calibrate = NULL, keep_cols = NULL, latlng = TRUE, minRSSI = 0)
```

**Arguments**  

* freq: this is the interval a localization should be summarized over, and is in the form of an interval (e.g. `"3 min"`)  
* beep_data: raw beep data frame (e.g. `all_data[[1]][[1]]` from example.R)  
* node: read in node file  
* node_health: node health data frame
* MAX_NODES: the max number of nodes that should contribute to a localization. default = 0 means all nodes 
* tag_id: a vector of tags to calculate locations for
* calibrate: the session ID if you want to calculate over the entire duration a tag was left at a point
* keep_cols: if there are valuable columns that shouldn't be dropped
* latlng: BUGGY DO NOT USE YET
* minRSSI: the minimum RSSI of data used for the location estimate

**Value**  
A SpatialPointsDataFrame of estimated locations 

## Triangulation Functions  

### Data Prep  
**Description**  
This function prepares beep data to be input into the triangulation.    

**Usage**  
```{r eval=FALSE}
loc_prep(beep_data, nodes, freq) 
```

**Arguments**  

* beep_data: beep data frame  
* nodes: node file  
* freq: interval to calculate locations over  

**Value**  
A data frame that can be used as input to the `triangulate()` function  

### Calibration  
**Description**  
You can go this route if you e.g. left tags at a known location in your grid for a period of time. This function preps the beep data frame for input into the triangulation function, and also implements a calibration by fitting an asymptotic function for RSSI and distance.  

The calibration data frame needs the following column names:  

* pt: this can be any identifier for a given location used in the calibration  
* session_id: this can be any identifier for the time period the tag was at this spot  
* start: the beginning of the time interval when the tag was placed at the point, in POSIXct UTC  
* end: the end of the time interval when the tag was placed at the point, in POSIXct UTC  
* TagId: the tag ID left at the point  
* TagLat: latitude of the point  
* TagLng: longitude of the point  

**Usage**  
```{r eval=FALSE}
calibrate(beep_data, calibration, nodes, calibrate = TRUE, freq = "3 min", max_nodes = 0)
```

**Arguments**  
The option `calibrate = TRUE` is the default, and means that summary stats will be calculated over the entire time interval for each calibration location. Otherwise, pass `calibrate = FALSE, freq = <interval>` for the time interval of interest.  

* beep_data: beep data frame  
* calibration: data frame described above  
* nodes: node file  
* calibrate: whether or not the entire time interval a tag was at a point should be used for the estimation
* freq: alternatively, specify an interval for location estimation
* max_nodes: how many nodes should contribute? default = 0 means all nodes  

**Value**  
This function returns a list, the items of which are...  

1. data frame to be input into the triangulation  
2. a (see below)  
3. S (see below)  
4. K (see below)  

### Custom Distance Function  
**Description**  
You can pass a custom distance function to the triangulation, in the form of a string, that represents the relationship between RSSI and distance for your system. The string that you pass is the right side of the formula, where the left side is distance. The string needs to contain `x` which refers to RSSI. An example of an asymptotic relationship can be generated by the following function and the output of the calibrate function:

**Usage**  
```{r eval=FALSE}
relate(a, S, K)
```

**Arguments**  
These are fitted coefficients from an `SSasymp()` model relating distance to RSSI    

* a = R0 e.g. the 2nd item returned from the calibrate function  
* S = exp(lrc) e.g. the 3rd item returned from the calibrate function  
* K = Aysm e.g. the 4th item returned from the calibrate function  

**Value**  
Inspect that string if you would like to instead create your own (e.g. for tag-wise calibration)  

### Triangulation  

**Description**  
This performs the triangulation with an input data frame and defined distance relationship. You could e.g. fit a relationship between distance and RSSI based on your calibration work.

**Usage**  
```{r eval=FALSE}
triangulate(all_data, rssi = -100, node = 3, distance = relation)
```
**Arguments**  

* all_data: a formatted data frame, such as the output from `loc_prep()` or the data frame returned by `calibrate()`  
* rssi: the minimum RSSI threshold to incorporate data into the location calculation  
* node: the maximum number of nodes to contribute to the calculation  
* distance: a string representing the right side of a formula relating RSSI to distance, where distance is the left side and RSSI is `x` in the string  

**Value**  
A data frame with estimated locations and error